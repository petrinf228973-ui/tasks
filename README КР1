1) БЛОЧНАЯ СОРТИРОВКА (BUCKET SORT)

Описание алгоритма:  
Алгоритм распределяет элементы по "корзинам" в зависимости от их значений, затем сортирует каждую корзину отдельно и объединяет результаты.

Ключевые элементы кода:
- len(arr) - определение размера массива
- Создание корзин: [[] for _ in range(num_buckets)]
- Вычисление индекса корзины: int(num * num_buckets)
- Добавление в корзину: buckets[bucket_index].append(num)
- Сортировка корзин: sorted(bucket)
- Объединение результатов: sorted_arr.extend()

Сложность: O(n²) в худшем случае  
Анализ: Распределение O(n) + сортировка корзин O(Σm_i log m_i)

Тестовый прогон:

Вход: [0.42, 0.32, 0.67, 0.89, 0.11, 0.22]
Выход: [0.11, 0.22, 0.32, 0.42, 0.67, 0.89]


 2) БЛИННАЯ СОРТИРОВКА (PANCAKE SORT)

Описание алгоритма:  
Сортировка через последовательные перевороты частей массива, перемещая максимальные элементы в конец.

Ключевые элементы кода:
- Функция переворота flip(subarray_end)
- Поиск максимума: arr.index(max(arr[:size]))
- Цикл с уменьшением размера: for size in range(n, 1, -1)
- Обмен элементов: arr[start], arr[subarray_end] = arr[subarray_end], arr[start]

Сложность: O(n²)  
Анализ: O(n) поисков максимума × O(n) операций переворота

Тестовый прогон:

Вход: [64, 34, 25, 12, 22, 11, 90]
Выход: [11, 12, 22, 25, 34, 64, 90]


3) СОРТИРОВКА БУСИНАМИ (BEAD SORT)

Описание алгоритма:  
Визуализация сортировки через "падение бусин" под действием гравитации.

Ключевые элементы кода:
- Создание абака: [[0] * max_val for _ in range(len(arr))]
- Расстановка бусин: beads[i][j] = 1
- Подсчет столбцов: sum(beads[i][j] for i in range(len(arr)))
- Преобразование обратно: [sum(row) for row in beads]

Сложность: O(S), где S - сумма элементов  
Анализ: Зависит от максимального значения в массиве

Тестовый прогон:

Вход: [4, 1, 6, 2, 3]
Выход: [1, 2, 3, 4, 6]


4) ПОИСК СКАЧКАМИ (JUMP SEARCH)

Описание алгоритма:  
Поиск в отсортированном массиве через прыжки фиксированного размера с последующим линейным поиском в блоке.

Ключевые элементы кода:
- Размер прыжка: step = int(n ** 0.5)
- Поиск блока: while prev < n and arr[min(step, n) - 1] < target
- Линейный поиск: for i in range(prev, min(step, n))

Сложность: O(√n)  
Анализ: √n прыжков + √n проверок в блоке

Тестовый прогон:

Массив: [2, 5, 8, 12, 16, 23, 38, 45, 67, 73]
Поиск 23 → индекс 5


5) ЭКСПОНЕНЦИАЛЬНЫЙ ПОИСК (EXPONENTIAL SEARCH)

Описание алгоритма:  
Быстрое определение диапазона через экспоненциальное расширение границ с последующим бинарным поиском.

Ключевые элементы кода:
- Экспоненциальное расширение: while i < n and arr[i] <= target
- Удвоение границы: i *= 2
- Бинарный поиск: while left <= right с mid = (left + right) // 2

Сложность: O(log n)  
Анализ: O(log n) на расширение + O(log n) на бинарный поиск

Тестовый прогон:

Массив: [2, 5, 8, 12, 16, 23, 38, 45, 67, 73]
Поиск 45 → индекс 7


 6) ТЕРНАРНЫЙ ПОИСК (TERNARY SEARCH)

Описание алгоритма:  
Рекурсивное деление массива на три части для быстрого сужения области поиска.

Ключевые элементы кода:
- Точки деления: mid1 = left + (right - left) // 3, mid2 = right - (right - left) // 3
- Рекурсивные вызовы для трех случаев
- Базовый случай: if left > right: return -1

Сложность: O(log₃n)  
Анализ: На каждом шаге область поиска уменьшается в 3 раза

Тестовый прогон:

Массив: [2, 5, 8, 12, 16, 23, 38, 45, 67, 73]
Поиск 16 → индекс 4
